//! Rate limiting middleware.

use {
    crate::{config, server},
    actix_governor::{Governor, GovernorConfigBuilder},
    actix_web::{middleware, App, HttpServer},
    anyhow::Result,
    app::App,
    common::routes::{ASSETS_PATH, DEV_PORT},
    leptos::{view, LeptosOptions},
    leptos_actix::LeptosRoutes,
    std::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr},
};

mod client_ip;
mod tls;

/// Start the backend http server.
/// The sever will block waiting for requests.
pub async fn run() -> Result<()> {
    let cfg = config::get();

    let governor_configuration = GovernorConfigBuilder::default()
        .per_millisecond(cfg.rate_limiter_replenish_rate_milliseconds.into())
        .burst_size(cfg.rate_limiter_burst_size.into())
        .key_extractor(server::client_ip::Extractor)
        .use_headers()
        .finish()
        .unwrap();

    let routes = leptos_actix::generate_route_list(|cx| view! { cx, <App/> });

    let server = HttpServer::new(move || {
        App::new()
            .leptos_routes(
                leptos_options(),
                routes.to_owned(),
                |cx| view! { cx, <App/> },
            )
            .wrap(Governor::new(&governor_configuration))
            .wrap(middleware::Logger::new("%s for %U %a in %Ts"))
            .wrap(sentry_actix::Sentry::new())
            .wrap(middleware::Compress::default())
            .wrap(actix_web_lab::middleware::RedirectHttps::with_hsts(
                if [
                    config::Environment::Staging,
                    config::Environment::Production,
                ]
                .contains(&cfg.environment)
                {
                    actix_web_lab::header::StrictTransportSecurity::recommended()
                } else {
                    actix_web_lab::header::StrictTransportSecurity::default()
                },
            ))
            .wrap(middleware::NormalizePath::new(
                middleware::TrailingSlash::Trim,
            ))
            .configure(crate::handlers::routes)
    })
    .shutdown_timeout(config::GRACEFUL_SHUTDOWN_TIMEOUT_SECONDS);

    let server = match &cfg.tls_config {
        None => {
            if !cfg!(debug_assertions) {
                panic!("running in production without tls configured is not allowed");
            }
            server.bind(
                [
                    SocketAddr::new(Ipv4Addr::LOCALHOST.into(), DEV_PORT),
                    SocketAddr::new(Ipv6Addr::LOCALHOST.into(), DEV_PORT),
                ]
                .as_ref(),
            )?
        }
        Some(tls_config) => server
            .bind(
                [
                    SocketAddr::new(Ipv4Addr::UNSPECIFIED.into(), 80),
                    SocketAddr::new(Ipv6Addr::UNSPECIFIED.into(), 80),
                ]
                .as_ref(),
            )?
            .bind_rustls(
                [
                    SocketAddr::new(Ipv4Addr::UNSPECIFIED.into(), 443),
                    SocketAddr::new(Ipv6Addr::UNSPECIFIED.into(), 443),
                ]
                .as_ref(),
                tls::build_server_config(tls_config)?,
            )?,
    };
    tracing::info!(socket_addresses = ?server.addrs(), "binding");
    tracing::info!("âœ… ready");
    server.run().await?;

    Ok(())
}

fn leptos_options() -> LeptosOptions {
    LeptosOptions {
        // the name to use as a suffix for the wasm and js modules of the webapp.
        // can be anything as all files in assets directories are served
        output_name: "app".into(),
        // the path of the all the files generated by cargo-leptos. This
        // defaults to '.' for convenience when integrating with other
        // tools
        site_root: ".".into(),
        // the path of the assets directory where the wasm and js files are served from
        site_pkg_dir: ASSETS_PATH.into(),
        // use leptos PROD to disable leptos from emitting websocket code for reloading
        env: leptos::leptos_config::Env::PROD,
        /// Provides a way to control the address leptos is served from.
        /// Using an env variable here would allow you to run the same code in
        /// dev and prod Defaults to `127.0.0.1:3000`
        site_addr: SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), 0),
        /// not using hot reloading, so any value is fine
        reload_port: 0,
    }
}
